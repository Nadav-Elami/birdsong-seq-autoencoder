# Model Architecture Patterns

## Model Initialization
- Use type hints for all constructor parameters
- Validate input parameters in `__init__`
- Set device and dtype consistently
- Register buffers for non-trainable parameters

## Forward Pass
- Use `torch.nn.Module` as base class
- Implement `forward()` method with clear input/output contract
- Handle both training and evaluation modes
- Return dictionary with named outputs

## Loss Functions
- Implement loss computation as separate method
- Use reparameterization trick for variational inference
- Handle multiple samples for Monte Carlo estimation
- Return both total loss and component breakdown

## Numerical Stability
- Use `torch.clamp()` to avoid log(0) in loss computation
- Add small epsilon (1e-12) to denominators
- Use `torch.exp(0.5 * logvar)` for standard deviation
- Check for NaN/Inf values in loss computation

## Model Components
- Use GRU/LSTM for sequential processing
- Implement bidirectional networks for full sequence context
- Use linear layers for dimension transformations
- Apply activation functions consistently

## Error Handling
- Validate input shapes and types
- Check for valid alphabet sizes and orders
- Handle edge cases (empty sequences, invalid transitions)
- Provide clear error messages for debugging

## Testing
- Test forward pass with various input shapes
- Validate loss computation with known inputs
- Test gradient flow and numerical stability
- Use small models for fast testing
description:
globs:
alwaysApply: false
---
