# Testing Patterns

## Regression Testing
- Compare outputs between original scripts and new package
- Use tolerance of 1e-5 for numerical comparisons
- Test with deterministic seeds for reproducibility
- Validate shapes, types, and value ranges

## Test Structure
- Use pytest fixtures for common setup
- Group related tests in test classes
- Use descriptive test names
- Test both happy path and edge cases

## Numerical Validation
- Check for finite values in loss computation
- Validate probability distributions sum to 1
- Test gradient flow and backpropagation
- Verify KL divergence is non-negative

## Data Testing
- Test data generation with known parameters
- Validate HDF5 file format and contents
- Test dataset loading with various file sizes
- Check data preprocessing and augmentation

## Model Testing
- Test model initialization with various parameters
- Validate forward pass with different input shapes
- Test loss computation with known inputs/outputs
- Verify model state management (train/eval modes)

## Integration Testing
- Test complete pipeline from data to training
- Validate CLI interfaces with various arguments
- Test checkpoint saving and loading
- Verify evaluation metrics and visualization

## Performance Testing
- Test memory usage with large datasets
- Validate training speed and convergence
- Test GPU/CPU compatibility
- Check for memory leaks in long runs

## Error Testing
- Test invalid input handling
- Validate error messages are informative
- Test edge cases (empty data, invalid parameters)
- Check exception propagation

## Test Data
- Use small, deterministic datasets for fast testing
- Create fixtures for common test scenarios
- Use temporary files for I/O testing
- Clean up test artifacts after tests
description:
globs:
alwaysApply: false
---
